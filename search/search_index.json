{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Aegis Stack \ud83d\udee1\ufe0f","text":"<p>Build production-ready Python applications with your chosen components.</p> <p>Aegis Stack is a CLI-driven framework for creating custom Python applications. Select exactly the components you need - no bloat, no unused dependencies.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code># Install\npip install aegis-stack\n\n# Create a simple API\naegis init my-api\n\n# Create with background processing  \naegis init task-processor --components scheduler\n\n# Start building\ncd my-project &amp;&amp; uv sync &amp;&amp; source .venv/bin/activate &amp;&amp; make run-local\n</code></pre>"},{"location":"#available-components","title":"\ud83e\udde9 Available Components","text":"Component Purpose Status Core (FastAPI + Flet) Web API + Frontend \u2705 Included Scheduler Background tasks, cron jobs \u2705 Available Database PostgreSQL + SQLAlchemy + Alembic \ud83d\udea7 Coming Soon Cache Redis caching and sessions \ud83d\udea7 Coming Soon"},{"location":"#what-you-get","title":"What You Get","text":"<ul> <li>FastAPI backend with automatic API documentation</li> <li>Flet frontend with system health dashboard  </li> <li>CLI management with health monitoring commands</li> <li>Production ready with structured logging and containerization</li> <li>Async-first architecture for high-concurrency workloads</li> </ul>"},{"location":"#system-health-dashboard","title":"\ud83d\udcf1 System Health Dashboard","text":"<p>Real-time monitoring with component status, health percentages, and cross-platform deployment (web, desktop, mobile).</p>"},{"location":"#learn-more","title":"\ud83d\udcda Learn More","text":"<ul> <li>\ud83d\udcd6 CLI Reference - Complete command reference</li> <li>\ud83c\udfd7\ufe0f Components - Deep dive into available components  </li> <li>\ud83e\udde0 Philosophy - Architecture and design principles</li> </ul>"},{"location":"#development-commands","title":"Development Commands","text":"<pre><code>make run-local    # Start development server\nmake test         # Run test suite  \nmake check        # Run all quality checks\nmake docs-serve   # Serve documentation\n</code></pre> <p>Built on FastAPI, Flet, Typer, and other open-source tools.</p>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>Complete reference for the Aegis Stack command-line interface.</p>"},{"location":"cli-reference/#aegis-init","title":"aegis init","text":"<p>Create a new Aegis Stack project with your chosen components.</p> <p>Usage: <pre><code>aegis init PROJECT_NAME [OPTIONS]\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>PROJECT_NAME</code> - Name of the new project to create (required)</li> </ul> <p>Options:</p> <ul> <li><code>--components, -c TEXT</code> - Comma-separated list of components (scheduler,database,cache)</li> <li><code>--interactive / --no-interactive, -i / -ni</code> - Use interactive component selection (default: interactive)</li> <li><code>--force, -f</code> - Overwrite existing directory if it exists</li> <li><code>--output-dir, -o PATH</code> - Directory to create the project in (default: current directory) </li> <li><code>--yes, -y</code> - Skip confirmation prompt</li> </ul> <p>Examples: <pre><code># Simple API project\naegis init my-api\n\n# Background processing system\naegis init task-processor --components scheduler\n\n# Full stack (future)\naegis init webapp --components scheduler,database,cache\n\n# Non-interactive with custom location\naegis init my-app --components scheduler --no-interactive --output-dir /projects --yes\n</code></pre></p> <p>Available Components:</p> Component Status Description <code>scheduler</code> \u2705 Available APScheduler-based async task scheduling <code>database</code> \ud83d\udea7 Coming Soon SQLAlchemy + asyncpg for PostgreSQL <code>cache</code> \ud83d\udea7 Coming Soon Redis-based async caching"},{"location":"cli-reference/#aegis-version","title":"aegis version","text":"<p>Show the Aegis Stack CLI version.</p> <p>Usage: <pre><code>aegis version\n</code></pre></p> <p>Example Output: <pre><code>Aegis Stack CLI v1.0.0\n</code></pre></p>"},{"location":"cli-reference/#global-options","title":"Global Options","text":"<p>Help: <pre><code>aegis --help          # Show general help\naegis COMMAND --help  # Show help for specific command\n</code></pre></p>"},{"location":"cli-reference/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - Success</li> <li><code>1</code> - Error (invalid arguments, project creation failed, etc.)</li> </ul>"},{"location":"cli-reference/#environment","title":"Environment","text":"<p>The CLI respects these environment variables:</p> <ul> <li>Standard Python environment variables</li> <li>UV environment variables (for dependency management)</li> </ul>"},{"location":"cli-reference/#project-structure","title":"Project Structure","text":"<p>Projects created with <code>aegis init</code> follow this structure:</p> <pre><code>my-project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 backend/        # FastAPI backend\n\u2502   \u2502   \u251c\u2500\u2500 frontend/       # Flet frontend  \n\u2502   \u2502   \u2514\u2500\u2500 scheduler.py    # APScheduler (if included)\n\u2502   \u251c\u2500\u2500 core/              # Framework utilities\n\u2502   \u251c\u2500\u2500 services/          # Business logic\n\u2502   \u2514\u2500\u2500 integrations/      # App composition\n\u251c\u2500\u2500 tests/                 # Test suite\n\u251c\u2500\u2500 docs/                  # Documentation\n\u251c\u2500\u2500 pyproject.toml         # Project configuration\n\u251c\u2500\u2500 Dockerfile             # Container definition\n\u251c\u2500\u2500 docker-compose.yml     # Multi-service orchestration\n\u251c\u2500\u2500 Makefile              # Development commands\n\u2514\u2500\u2500 .env.example          # Environment template\n</code></pre>"},{"location":"cli-reference/#development-workflow","title":"Development Workflow","text":"<p>After creating a project:</p> <pre><code>cd my-project\nuv sync                    # Install dependencies and create virtual environment\nsource .venv/bin/activate  # Activate virtual environment (important!)\ncp .env.example .env       # Configure environment\nmake run-local             # Start development server\nmake test                  # Run test suite\nmake check                 # Run all quality checks\n</code></pre>"},{"location":"integration-patterns/","title":"Integration Patterns Reference","text":"<p>Quick reference for how different parts of Aegis Stack integrate with each other.</p>"},{"location":"integration-patterns/#backend-integration-patterns","title":"Backend Integration Patterns","text":"<p>\ud83d\udd04 Auto-Discovered: Drop files, no registration required</p> <ul> <li>Middleware: <code>app/components/backend/middleware/</code></li> <li>Startup Hooks: <code>app/components/backend/startup/</code> </li> <li>Shutdown Hooks: <code>app/components/backend/shutdown/</code></li> </ul> <p>\ud83d\udcdd Manual Registration: Explicit imports for clarity</p> <ul> <li>API Routes: Register in <code>app/components/backend/api/routing.py</code></li> <li>Services: Import explicitly where needed</li> </ul>"},{"location":"integration-patterns/#service-integration-patterns","title":"Service Integration Patterns","text":"<p>Put your business logic in <code>app/services/</code> and import it explicitly where needed.</p> <p>Services contain pure business logic functions. Components import and use them.</p> <pre><code># app/services/report_service.py\nasync def generate_monthly_report(user_id: int) -&gt; Report:\n    # Your business logic here\n    pass\n\n# app/components/backend/api/reports.py  \nfrom app.services.report_service import generate_monthly_report\n\n@router.post(\"/reports\")\nasync def create_report(user_id: int):\n    return await generate_monthly_report(user_id)\n\n# app/components/scheduler/main.py\nfrom app.services.report_service import generate_monthly_report\n\nscheduler.add_job(generate_monthly_report, args=[123])\n</code></pre> <p>What Goes Where:</p> <p>Services (<code>app/services/</code>):</p> <ul> <li>Database interactions, external API calls, file processing</li> <li>Complex business logic and data transformations  </li> <li>Pure functions that can be unit tested</li> <li>Single files (<code>report_service.py</code>) or folders (<code>system/health.py</code>) for complex domains</li> </ul> <p>Components (<code>app/components/</code>):</p> <ul> <li>API endpoints, scheduled jobs, UI handlers</li> <li>Import services explicitly - no magic auto-discovery</li> <li>Keep thin - handle requests, call services, return responses</li> </ul> <p>Why explicit? Makes dependencies clear, prevents surprises, easier testing.</p>"},{"location":"integration-patterns/#component-communication","title":"Component Communication","text":"<p>Backend \u2194 Services: Direct imports <pre><code>from app.services.system import get_system_status\n</code></pre></p> <p>CLI \u2194 Backend: HTTP API calls <pre><code>from app.services.system.models import HealthResponse\nhealth_data = HealthResponse.model_validate(api_response.json())\n</code></pre></p> <p>Frontend \u2194 Backend: Flet-FastAPI integration <pre><code>from app.services.system import get_system_status\n# Direct function calls within same process\n</code></pre></p>"},{"location":"integration-patterns/#data-validation-boundaries","title":"Data Validation Boundaries","text":"<p>Trust Zones: Validate at entry points, trust internally</p> <ol> <li>API Endpoints: Pydantic <code>response_model</code> validates outgoing data</li> <li>CLI Commands: Pydantic models validate API responses  </li> <li>Internal Code: Direct model attribute access (no <code>.get()</code> patterns)</li> </ol> <pre><code># Entry point - validate hard\n@router.get(\"/health\", response_model=HealthResponse)\nasync def health_check() -&gt; HealthResponse:\n    # Internal code - trust the data\n    status = await get_system_status()\n    return HealthResponse(healthy=status.overall_healthy, ...)\n\n# CLI - validate API response\nhealth_data = HealthResponse.model_validate(response.json())\n# Then trust: health_data.healthy (not health_data.get(\"healthy\"))\n</code></pre>"},{"location":"integration-patterns/#scheduler-integration","title":"Scheduler Integration","text":"<p>Job Registration: Explicit in scheduler component</p> <pre><code># app/components/scheduler/main.py\nfrom app.services.reports import generate_daily_report\n\nscheduler.add_job(\n    generate_daily_report,\n    trigger=\"cron\", \n    hour=9, minute=0\n)\n</code></pre> <p>Service Functions: Pure business logic <pre><code># app/services/reports.py\nasync def generate_daily_report() -&gt; None:\n    # Pure business logic, no scheduler dependencies\n</code></pre></p>"},{"location":"integration-patterns/#configuration-access","title":"Configuration Access","text":"<p>Global Settings: Available everywhere</p> <pre><code>from app.core.config import settings\n\n# Use throughout application\ndatabase_url = settings.DATABASE_URL\napi_timeout = settings.API_TIMEOUT\n</code></pre> <p>Constants vs Config:</p> <ul> <li>Constants (<code>app.core.constants</code>): Immutable values (API paths, timeouts)</li> <li>Config (<code>app.core.config</code>): Environment-dependent values (URLs, secrets)</li> </ul>"},{"location":"integration-patterns/#container-boundaries","title":"Container Boundaries","text":"<p>Each component manages its own concerns:</p> <ul> <li>Backend Container: Runs FastAPI + Flet, manages backend hooks</li> <li>Scheduler Container: Runs APScheduler, manages scheduled jobs</li> <li>Shared: Services, core utilities, configuration</li> </ul> <p>No Cross-Container Hooks: Backend hooks don't affect scheduler, and vice versa.</p>"},{"location":"integration-patterns/#key-principles","title":"Key Principles","text":"<ol> <li>Auto-discovery for infrastructure (hooks) \u2192 convenience</li> <li>Explicit imports for business logic (services, routes) \u2192 clarity  </li> <li>Validate at boundaries \u2192 security and reliability</li> <li>Trust internally \u2192 clean, readable code</li> <li>Container isolation \u2192 independent scaling</li> </ol>"},{"location":"philosophy/","title":"Aegis Stack Philosophy","text":"<p>Aegis Stack believes in choice over convention - build exactly the application you need, nothing more, nothing less.</p> <p>Built on three pillars: Speed, Simplicity, and Scalability.</p>"},{"location":"philosophy/#speed-for-builders-who-refuse-to-wait","title":"Speed: For Builders Who Refuse to Wait","text":"<p>Development should be fast. Aegis Stack gets you from idea to production quickly.</p> <ul> <li>CLI-Driven Generation: <code>aegis init</code> creates a working application in seconds</li> <li>Async-First: Built with <code>asyncio</code> for high-concurrency workloads</li> <li>Full-Stack Python: Single language for your entire stack</li> <li>Minimalist by Default: No unnecessary bloat or framework overhead</li> </ul>"},{"location":"philosophy/#simplicity-powerful-patterns-not-prescriptive-frameworks","title":"Simplicity: Powerful Patterns, Not Prescriptive Frameworks","text":"<p>Aegis Stack favors clear, Pythonic patterns over complex, magical frameworks.</p> <ul> <li>Transparent Integration: Components expose capabilities through simple, documented interfaces</li> <li>Clear Separation: Components (capabilities), services (business logic), entrypoints (execution modes)</li> <li>Predictable Structure: Every project follows the same organizational patterns</li> <li>Explicit Dependencies: Import what you need where you need it</li> </ul>"},{"location":"philosophy/#component-composition-build-exactly-what-you-need","title":"Component Composition: Build Exactly What You Need","text":"<p>Aegis Stack rejects \"one-size-fits-all\" frameworks. Instead, compose exactly the capabilities your application requires.</p> <pre><code># Simple API service\naegis init api-service\n\n# Background processing system\naegis init processor --components scheduler\n\n# Full application (future)\naegis init webapp --components scheduler,database,cache\n</code></pre> <p>Components are capabilities, not implementations. When you choose \"scheduler,\" you're choosing the capability to run background tasks. The current implementation uses APScheduler.</p> <p>No unused dependencies. Your <code>pyproject.toml</code> only includes what you actually use. Choose scheduler? You get APScheduler. Skip the database? No SQLAlchemy cluttering your environment.</p> <p>Container-native deployment. Each component runs in its own Docker container, enabling you to scale the parts of your application that need it most.</p>"},{"location":"philosophy/#scalability-container-native-growth","title":"Scalability: Container-Native Growth","text":"<p>Start simple, scale smart as your application grows. Components run in separate Docker containers from day one, enabling resource optimization, independent scaling, and fault isolation.</p> <pre><code>graph TB\n    subgraph \"Phase 1: Simple Start\"\n        A1[Single Container&lt;br/&gt;All Components]\n    end\n\n    subgraph \"Phase 2: Component Separation\"\n        B1[Web Container&lt;br/&gt;API + Frontend]\n        B2[Worker Container&lt;br/&gt;Scheduler + Jobs]\n        B3[Database&lt;br/&gt;PostgreSQL]\n    end\n\n    subgraph \"Phase 3: Microservices\"\n        C1[API Service]\n        C2[Frontend Service]\n        C3[Scheduler Service]\n        C4[Database Cluster]\n        C5[Cache Cluster]\n        C6[Message Queue]\n    end\n\n    A1 --&gt; B1\n    A1 --&gt; B2\n    A1 --&gt; B3\n\n    B1 --&gt; C1\n    B1 --&gt; C2\n    B2 --&gt; C3\n    B3 --&gt; C4\n    B2 --&gt; C5\n    B2 --&gt; C6\n\n    style A1 fill:#e1f5fe\n    style B1 fill:#e8f5e8\n    style B2 fill:#e8f5e8\n    style B3 fill:#e8f5e8\n    style C1 fill:#f3e5f5\n    style C2 fill:#f3e5f5\n    style C3 fill:#f3e5f5</code></pre>"},{"location":"philosophy/#the-aegis-stack-promise","title":"The Aegis Stack Promise","text":"<p>Choose your components. Get exactly the capabilities you need. Start simple. Deploy as a single application. Scale smart. Distribute components as your needs grow. Stay in control. No vendor lock-in, no framework magic, just clear Python patterns.</p> <p>Aegis Stack doesn't make architectural decisions for you - it provides the tools to make them yourself.</p>"},{"location":"technology/","title":"Technology Stack","text":"<p>Aegis Stack is built on the shoulders of giants. Each tool was thoughtfully selected for its excellence in solving specific problems, and for how well it composes with others.</p>"},{"location":"technology/#core-framework","title":"Core Framework","text":""},{"location":"technology/#fastapi-by-sebastian-ramirez","title":"FastAPI by Sebasti\u00e1n Ram\u00edrez","text":"<p>Why FastAPI: High-performance async web framework with automatic API documentation</p> <p>Sebasti\u00e1n Ram\u00edrez built something special that makes high-performance Python web development accessible. FastAPI brings several advantages that align perfectly with Aegis Stack's philosophy:</p> <ul> <li>Async-first design - Built for high-concurrency workloads from the ground up</li> <li>Automatic API documentation - Interactive Swagger UI and ReDoc generation</li> <li>Type safety integration - Leverages Python type hints for validation and serialization  </li> <li>High performance - On par with NodeJS and Go thanks to Starlette and Pydantic</li> <li>Developer experience - Excellent editor support with autocompletion and error detection</li> </ul>"},{"location":"technology/#flet-by-feodor-fitsner","title":"Flet by Feodor Fitsner","text":"<p>Why Flet: Python-native cross-platform UI framework</p> <p>Feodor Fitsner created a framework that lets Python developers build rich interfaces without leaving their language comfort zone. Flet enables:</p> <ul> <li>True Python-native UI - No need to learn JavaScript, HTML, or CSS</li> <li>Cross-platform deployment - Web, desktop, and mobile from the same codebase</li> <li>Real-time updates - WebSocket-based UI updates for dynamic interfaces</li> <li>Flutter foundation - Built on Google's Flutter for native performance</li> <li>Reactive programming - Natural async/await patterns for UI interactions</li> </ul>"},{"location":"technology/#typer-by-sebastian-ramirez","title":"Typer by Sebasti\u00e1n Ram\u00edrez","text":"<p>Why Typer: Modern CLI framework with excellent Python integration</p> <p>The perfect complement to FastAPI for CLI applications. Typer enables our \"hook into existing Python logic\" philosophy by making CLI commands feel like natural extensions of your application code:</p> <ul> <li>Type-driven interface - CLI arguments and options inferred from function signatures</li> <li>Rich integration - Beautiful terminal formatting out of the box</li> <li>Automatic help generation - Documentation from docstrings and type hints</li> <li>Validation and conversion - Automatic parsing and validation of CLI inputs</li> <li>Composable commands - Easy sub-command organization</li> </ul>"},{"location":"technology/#development-tooling-excellence","title":"Development &amp; Tooling Excellence","text":""},{"location":"technology/#uv-by-astral","title":"UV by Astral","text":"<p>Why UV: Blazing fast Python package manager and environment tool</p> <p>Astral's UV represents a generational leap in Python tooling speed and reliability. It makes dependency management fast enough to disappear from your development workflow:</p> <ul> <li>Rust-powered performance - 10-100x faster than pip for most operations</li> <li>Unified tooling - Package management, virtual environments, and project setup</li> <li>Universal compatibility - Works with existing pip/Poetry/PDM workflows</li> <li>Reliable resolution - Better dependency resolution than traditional tools</li> <li>Production ready - Used by major Python projects and organizations</li> </ul>"},{"location":"technology/#rich-by-will-mcgugan","title":"Rich by Will McGugan","text":"<p>Why Rich: Beautiful terminal formatting and progress displays</p> <p>Will McGugan's Rich transforms terminal interfaces from afterthoughts into delightful user experiences. It makes CLI tools feel modern and professional:</p> <ul> <li>Beautiful formatting - Rich text, tables, progress bars, and syntax highlighting</li> <li>Color and style - Automatic color detection and graceful degradation</li> <li>Interactive elements - Progress bars, spinners, and status displays</li> <li>Cross-platform - Consistent experience across Windows, macOS, and Linux</li> <li>Developer friendly - Simple APIs that make complex formatting trivial</li> </ul>"},{"location":"technology/#ruff-by-astral","title":"Ruff by Astral","text":"<p>Why Ruff: Lightning-fast Python linter and formatter</p> <p>Astral's Ruff brings Rust-level performance to Python linting. It's fast enough to run on every file save without breaking your flow:</p> <ul> <li>Extreme performance - 10-100x faster than existing Python linters</li> <li>Comprehensive rules - Replaces Flake8, isort, pyupgrade, and more</li> <li>Zero configuration - Sensible defaults that work out of the box</li> <li>Fix capable - Automatically fixes hundreds of rule violations</li> <li>Editor integration - Real-time feedback in VS Code, PyCharm, and others</li> </ul>"},{"location":"technology/#infrastructure-components","title":"Infrastructure &amp; Components","text":""},{"location":"technology/#apscheduler-by-alex-gronholm","title":"APScheduler by Alex Gr\u00f6nholm","text":"<p>Why APScheduler: Advanced Python scheduler for background tasks</p> <p>The most mature and feature-rich Python scheduler, providing enterprise-grade job scheduling:</p> <ul> <li>Multiple triggers - Cron, interval, date-based, and custom triggers</li> <li>Persistent storage - Database, Redis, or memory-based job stores</li> <li>Fault tolerance - Job persistence, retries, and graceful shutdown</li> <li>Async support - Native asyncio integration for non-blocking operations</li> <li>Monitoring - Job status tracking and execution history</li> </ul>"},{"location":"technology/#pydantic-by-samuel-colvin","title":"Pydantic by Samuel Colvin","text":"<p>Why Pydantic: Data validation using Python type annotations</p> <p>Samuel Colvin created the definitive solution for Python data validation. Pydantic provides:</p> <ul> <li>Runtime validation - Catch data issues immediately at entry points</li> <li>Type safety - Convert and validate data using Python type hints</li> <li>JSON serialization - Automatic conversion to/from JSON for APIs</li> <li>FastAPI integration - Native support for request/response validation</li> <li>Performance - Rust-powered validation for high-throughput applications</li> </ul>"},{"location":"technology/#structlog-by-hynek-schlawack","title":"Structlog by Hynek Schlawack","text":"<p>Why Structlog: Structured logging for production applications</p> <p>Hynek Schlawack's structlog transforms logging from an afterthought into a powerful observability tool:</p> <ul> <li>Structured data - JSON-based logs perfect for modern log aggregation</li> <li>Context preservation - Automatic request ID and user context tracking</li> <li>Performance - Lazy evaluation and efficient serialization</li> <li>Flexibility - Works with standard logging while adding structure</li> <li>Production ready - Used by major Python applications in production</li> </ul>"},{"location":"technology/#cookiecutter-by-audrey-feldroy","title":"Cookiecutter by Audrey Feldroy","text":"<p>Why Cookiecutter: Project template engine</p> <p>Audrey Feldroy created the gold standard for project scaffolding. Cookiecutter enables:</p> <ul> <li>Template-driven generation - Smart project creation from reusable templates</li> <li>Cross-platform - Works consistently across operating systems</li> <li>JSON configuration - Simple variable substitution and conditional logic</li> <li>Post-generation hooks - Custom processing after template rendering</li> <li>Community ecosystem - Thousands of existing templates for common patterns</li> </ul>"},{"location":"technology/#psutil-by-giampaolo-rodola","title":"psutil by Giampaolo Rodol\u00e0","text":"<p>Why psutil: Cross-platform system monitoring</p> <p>Giampaolo Rodol\u00e0's psutil provides the foundation for system monitoring across platforms:</p> <ul> <li>Universal API - Same interface for Windows, macOS, Linux, and BSD</li> <li>Comprehensive metrics - CPU, memory, disk, network, and process information</li> <li>Real-time data - Live system statistics for monitoring dashboards</li> <li>Lightweight - Minimal overhead for continuous monitoring</li> <li>Battle tested - Used by system administrators and monitoring tools worldwide</li> </ul>"},{"location":"technology/#integration-philosophy","title":"Integration Philosophy","text":"<p>Each tool was selected not just for its individual excellence, but for how well it composes with others:</p> <p>Async Ecosystem: FastAPI's async patterns work seamlessly with APScheduler's background tasks and Flet's reactive UI updates.</p> <p>Type Safety Chain: Pydantic's validation integrates naturally across FastAPI APIs, Typer CLI interfaces, and application configuration.</p> <p>Developer Experience: Typer's CLI design philosophy aligns perfectly with Rich's terminal formatting, while UV's speed keeps the development flow uninterrupted.</p> <p>Production Ready: Structlog's structured logging works beautifully with FastAPI's request tracking and APScheduler's job monitoring.</p>"},{"location":"technology/#the-curation-promise","title":"The Curation Promise","text":"<p>We curate, we don't compete. Aegis Stack's value lies in thoughtful integration of exceptional tools, not in rebuilding what others have perfected.</p> <p>Each tool represents years of development, community feedback, and real-world testing. By building on these foundations, Aegis Stack can focus on what matters: creating a cohesive, productive development experience that lets you build amazing applications.</p>"},{"location":"components/","title":"Components Overview","text":"<p>Components are the building blocks of your Aegis Stack application. Each component provides a specific capability like API serving, background tasks, or data persistence.</p> <p>\ud83d\udca1 New to Aegis Stack? See the Philosophy Guide for the complete component design principles.</p>"},{"location":"components/#component-selection","title":"Component Selection","text":"<p>\u26a0\ufe0f Important: Components must be selected during project creation. There is currently no way to add components to existing projects.</p> <pre><code># Basic stack (FastAPI + Flet)\naegis init my-project\n\n# Add scheduler capability\naegis init my-project --components scheduler\n\n# Multiple components (future)\naegis init my-project --components scheduler,database,cache\n</code></pre>"},{"location":"components/#component-architecture","title":"Component Architecture","text":"<pre><code>graph TB\n    subgraph \"Core Components (Always Included)\"\n        CLI[CLI Commands&lt;br/&gt;Typer]\n        API[FastAPI Backend&lt;br/&gt;Async REST API]\n        Frontend[Flet Frontend&lt;br/&gt;Cross-platform UI]\n    end\n\n    subgraph \"Optional Components\"\n        Scheduler[Scheduler&lt;br/&gt;APScheduler]\n        Database[Database&lt;br/&gt;PostgreSQL + SQLAlchemy]\n        Cache[Cache&lt;br/&gt;Redis]\n    end\n\n    subgraph \"Business Layer\"\n        Services[Services&lt;br/&gt;Pure Business Logic]\n        Constants[Constants&lt;br/&gt;Immutable Values]\n        Config[Configuration&lt;br/&gt;Environment Settings]\n    end\n\n    CLI --&gt; API\n    API --&gt; Frontend\n    API --&gt; Services\n    Services --&gt; Scheduler\n    Services --&gt; Database\n    Services --&gt; Cache\n    Services --&gt; Constants\n    Services --&gt; Config\n\n    style CLI fill:#e1f5fe\n    style API fill:#e8f5e8\n    style Frontend fill:#fff3e0\n    style Scheduler fill:#f3e5f5\n    style Database fill:#f3e5f5\n    style Cache fill:#f3e5f5</code></pre>"},{"location":"components/#available-components","title":"Available Components","text":"Component Purpose Implementation Status Core (Backend + Frontend + CLI) API + UI + Management FastAPI + Flet + Typer \u2705 Always included Scheduler Background tasks, cron jobs APScheduler \u2705 Available Database Data persistence, migrations PostgreSQL + SQLAlchemy \ud83d\udea7 Coming soon Cache Session storage, performance Redis \ud83d\udea7 Coming soon"},{"location":"components/#technology-integration","title":"Technology Integration","text":"<p>Each component integrates proven open-source technologies:</p> <ul> <li>Backend: FastAPI provides async web serving with automatic API documentation</li> <li>Frontend: Flet enables Python-native cross-platform UI development  </li> <li>CLI Integration: Typer creates command-line interfaces that hook directly into your Python logic</li> <li>Monitoring: Rich provides terminal formatting for CLI commands and health displays</li> <li>System Monitoring: psutil enables cross-platform system health monitoring</li> </ul> <p>Components are designed as capability interfaces - the current implementations can be replaced with alternatives while maintaining the same component API.</p>"},{"location":"components/#next-steps","title":"Next Steps","text":"<ul> <li>Backend Component - FastAPI backend configuration</li> <li>Frontend Component - Building user interfaces with Flet  </li> <li>Scheduler Component - Scheduling and cron job system</li> <li>Philosophy Guide - Component design principles and architecture</li> </ul>"},{"location":"components/frontend/","title":"Frontend Component","text":"<p>The Frontend Component provides the user interface for your Aegis Stack application using Flet - a Python-native framework for building web, desktop, and mobile apps by Feodor Fitsner.</p>"},{"location":"components/frontend/#basic-usage","title":"Basic Usage","text":"<p>Create your UI components in the frontend module:</p> <pre><code># app/components/frontend/main.py\nimport flet as ft\nfrom app.services.data_service import get_dashboard_stats\n\ndef create_frontend_app():\n    \"\"\"Create and return Flet session handler\"\"\"\n\n    async def main(page: ft.Page):\n        page.title = \"My Aegis App\"\n        page.theme_mode = ft.ThemeMode.LIGHT\n\n        # Data display\n        data_view = ft.Text(\"Loading...\", size=16)\n\n        async def load_data(e):\n            data = await get_dashboard_stats()\n            data_view.value = f\"Records: {data['count']}\"\n            page.update()\n\n        # Simple dashboard\n        page.add(\n            ft.Text(\"Dashboard\", size=24, weight=ft.FontWeight.BOLD),\n            ft.ElevatedButton(\"Load Data\", on_click=load_data),\n            data_view\n        )\n\n    return main\n</code></pre>"},{"location":"components/frontend/#integration-with-backend","title":"Integration with Backend","text":"<p>The frontend integrates with your FastAPI backend through the application composition:</p> <pre><code># app/integrations/main.py\nimport flet.fastapi as flet_fastapi\nfrom app.components.frontend.main import create_frontend_app\n\n# Mount Flet app on FastAPI\nsession_handler = create_frontend_app()\nflet_app = flet_fastapi.app(session_handler)\napp.mount(\"/dashboard\", flet_app)\n</code></pre>"},{"location":"components/frontend/#configuration","title":"Configuration","text":"<p>Flet runs through the backend container and is accessible at <code>http://localhost:8000/dashboard</code> during development.</p>"},{"location":"components/frontend/#system-health-dashboard","title":"System Health Dashboard","text":"<p>The Frontend Component includes a production-ready System Health Dashboard that showcases Flet's capabilities:</p> <p></p> <p>This dashboard demonstrates:</p> <ul> <li>Real-time data integration with backend APIs</li> <li>Responsive component layout with automatic updates</li> <li>Rich visual components including status cards and progress indicators</li> <li>Cross-platform compatibility - same code runs everywhere</li> </ul>"},{"location":"components/frontend/#technology-integration","title":"Technology Integration","text":"<p>The Frontend Component leverages Flet, created by Feodor Fitsner - a revolutionary approach to Python UI development that offers:</p>"},{"location":"components/frontend/#flets-innovation","title":"Flet's Innovation","text":"<ul> <li>Python-native - Write UI code entirely in Python, no HTML/CSS/JavaScript required</li> <li>Cross-platform - Same code runs as web app, desktop app, or mobile app</li> <li>Real-time updates - Changes reflect immediately without page refreshes</li> <li>Rich controls - Modern UI components with built-in theming and animations</li> <li>Flutter foundation - Built on Google's Flutter, inheriting its performance and polish</li> </ul>"},{"location":"components/frontend/#integration-advantages","title":"Integration Advantages","text":"<ul> <li>FastAPI integration - Seamless mounting on existing FastAPI applications</li> <li>Async support - Natural async/await patterns for backend API calls</li> <li>Type safety - Full Python type checking for UI logic</li> <li>Shared codebase - Frontend and backend share the same Python environment</li> </ul> <p>Flet was selected because it eliminates the traditional frontend/backend split, allowing Python developers to build complete applications without leaving their language expertise.</p>"},{"location":"components/frontend/#next-steps","title":"Next Steps","text":"<ul> <li>Flet Documentation - Complete UI framework capabilities</li> <li>Flet Controls Gallery - Available UI components  </li> <li>Component Overview - Understanding Aegis Stack's component architecture</li> <li>Philosophy Guide - Component architecture principles</li> </ul>"},{"location":"components/scheduler/","title":"Scheduler Component","text":"<p>The Scheduler Component provides scheduling and cron job capabilities for your Aegis Stack application using APScheduler.</p>"},{"location":"components/scheduler/#adding-scheduled-tasks","title":"Adding Scheduled Tasks","text":""},{"location":"components/scheduler/#step-1-create-service-functions","title":"Step 1: Create Service Functions","text":"<p>Add your business logic as functions in <code>app/services/</code>:</p> <pre><code># app/services/my_tasks.py\nfrom app.core.log import logger\n\nasync def send_daily_report() -&gt; None:\n    \"\"\"Generate and send daily reports.\"\"\"\n    logger.info(\"\ud83d\udcca Generating daily report\")\n    # Your report generation logic here\n    logger.info(\"\u2705 Daily report sent successfully\")\n\nasync def cleanup_temp_files() -&gt; None:\n    \"\"\"Clean up temporary files.\"\"\"\n    logger.info(\"\ud83d\uddd1\ufe0f Cleaning temporary files\")\n    # Your cleanup logic here\n\nasync def backup_database() -&gt; None:\n    \"\"\"Backup database weekly.\"\"\"\n    logger.info(\"\ud83d\udcbe Starting database backup\")\n    # Your backup logic here\n</code></pre>"},{"location":"components/scheduler/#step-2-schedule-your-tasks","title":"Step 2: Schedule Your Tasks","text":"<p>Add your jobs to the scheduler in <code>app/components/scheduler/main.py</code>:</p> <pre><code># app/components/scheduler/main.py\nfrom app.services.my_tasks import send_daily_report, cleanup_temp_files, backup_database\n\ndef create_scheduler() -&gt; AsyncIOScheduler:\n    \"\"\"Create and configure the scheduler with all jobs.\"\"\"\n    scheduler = AsyncIOScheduler()\n\n    # Add your scheduled tasks here:\n\n    # Daily report at 9 AM\n    scheduler.add_job(\n        send_daily_report,\n        trigger=\"cron\",\n        hour=9, minute=0,\n        id=\"daily_report\",\n        name=\"Daily Report Generation\"\n    )\n\n    # Clean temp files every 4 hours\n    scheduler.add_job(\n        cleanup_temp_files,\n        trigger=\"interval\",\n        hours=4,\n        id=\"temp_cleanup\",\n        name=\"Temporary Files Cleanup\"\n    )\n\n    # Weekly database backup on Sundays at 2 AM\n    scheduler.add_job(\n        backup_database,\n        trigger=\"cron\",\n        day_of_week=\"sun\",\n        hour=2, minute=0,\n        id=\"weekly_backup\",\n        name=\"Weekly Database Backup\"\n    )\n\n    return scheduler\n</code></pre>"},{"location":"components/scheduler/#common-scheduling-patterns","title":"Common Scheduling Patterns","text":""},{"location":"components/scheduler/#interval-based-tasks","title":"Interval-based Tasks","text":"<pre><code># Every 30 minutes\nscheduler.add_job(my_function, trigger=\"interval\", minutes=30)\n\n# Every 2 hours  \nscheduler.add_job(my_function, trigger=\"interval\", hours=2)\n\n# Every day\nscheduler.add_job(my_function, trigger=\"interval\", days=1)\n</code></pre>"},{"location":"components/scheduler/#cron-based-tasks","title":"Cron-based Tasks","text":"<pre><code># Daily at 6:30 AM\nscheduler.add_job(my_function, trigger=\"cron\", hour=6, minute=30)\n\n# Weekdays at 9 AM\nscheduler.add_job(my_function, trigger=\"cron\", day_of_week=\"mon-fri\", hour=9)\n\n# Last day of month at 11 PM\nscheduler.add_job(my_function, trigger=\"cron\", day=\"last\", hour=23)\n\n# Every Monday at 8 AM\nscheduler.add_job(my_function, trigger=\"cron\", day_of_week=\"mon\", hour=8)\n</code></pre>"},{"location":"components/scheduler/#configuration","title":"Configuration","text":"<p>Configure the scheduler through environment variables:</p> <pre><code># .env\nSCHEDULER_TIMEZONE=UTC\nSCHEDULER_MAX_WORKERS=10\nSCHEDULER_MISFIRE_GRACE_TIME=600  # 10 minutes\n</code></pre>"},{"location":"components/scheduler/#next-steps","title":"Next Steps","text":"<ul> <li>APScheduler Documentation - Complete scheduling capabilities</li> <li>Component Overview - Understanding Aegis Stack's component architecture</li> </ul>"},{"location":"components/webserver/","title":"Backend Component","text":"<p>The Backend Component handles HTTP requests and API endpoints for your Aegis Stack application using FastAPI.</p>"},{"location":"components/webserver/#adding-api-routes","title":"Adding API Routes","text":"<p>API routes require explicit registration to maintain clear dependency tracking:</p> <p>Step 1: Create your router <pre><code># app/components/backend/api/data.py\nfrom fastapi import APIRouter\nfrom app.services.data_service import get_dashboard_stats, trigger_manual_ingestion\n\nrouter = APIRouter()\n\n@router.get(\"/data/stats\")\nasync def get_stats():\n    stats = await get_dashboard_stats()\n    return {\"status\": \"success\", \"data\": stats}\n\n@router.post(\"/data/ingest\")\nasync def trigger_ingestion():\n    await trigger_manual_ingestion()\n    return {\"status\": \"ingestion_started\"}\n</code></pre></p> <p>Step 2: Register explicitly <pre><code># app/components/backend/api/routing.py\nfrom app.components.backend.api import data\n\ndef include_routers(app: FastAPI) -&gt; None:\n    app.include_router(data.router, prefix=\"/api\", tags=[\"data\"])\n</code></pre></p> <p>Why manual registration? API routes define your application's public interface. Explicit registration makes dependencies clear and prevents accidental exposure of endpoints.</p>"},{"location":"components/webserver/#adding-backend-hooks-auto-discovered","title":"Adding Backend Hooks (Auto-Discovered)","text":"<p>Backend hooks are automatically discovered by dropping files in designated folders:</p> <pre><code>app/components/backend/\n\u251c\u2500\u2500 middleware/     # Auto-discovered middleware  \n\u251c\u2500\u2500 startup/        # Auto-discovered startup hooks\n\u2514\u2500\u2500 shutdown/       # Auto-discovered shutdown hooks\n</code></pre> <p>Example: Add CORS middleware <pre><code># app/components/backend/middleware/cors.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\nasync def register_middleware(app: FastAPI) -&gt; None:\n    \"\"\"Auto-discovered middleware registration.\"\"\"\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"]\n    )\n</code></pre></p> <p>No registration required - just drop the file and restart. See the Integration Patterns for complete details.</p>"},{"location":"components/webserver/#integration","title":"Integration","text":"<p>FastAPI integrates with your application and provides:</p> <ul> <li>Interactive docs at <code>/docs</code> (Swagger UI)</li> <li>API schema at <code>/openapi.json</code> </li> <li>Health check at <code>/health</code></li> <li>CORS enabled for frontend integration</li> </ul>"},{"location":"components/webserver/#configuration","title":"Configuration","text":"<p>The backend runs on port 8000 and is configured through the integration layer with automatic JSON serialization and validation.</p>"},{"location":"components/webserver/#next-steps","title":"Next Steps","text":"<ul> <li>FastAPI Documentation - Complete API framework capabilities</li> <li>FastAPI Tutorial - Building APIs with FastAPI</li> <li>Component Overview - Understanding Aegis Stack's component architecture</li> <li>Philosophy Guide - Component architecture principles</li> </ul>"}]}