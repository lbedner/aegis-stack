{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Aegis Stack \ud83d\udee1\ufe0f","text":"<p>A production-ready, async-first Python foundation for builders who refuse to wait.</p> <p>Aegis Stack provides a minimal, yet powerful, set of tools and patterns to help you build and deploy robust, scalable applications quickly. It's designed for developers who think in systems, not scripts, and who value speed, simplicity, and scalability.</p>"},{"location":"index.html#core-features","title":"Core Features","text":"<ul> <li>Full-Stack Python: A unified development experience with FastAPI for the backend and Flet for the frontend.</li> <li>Async-First Architecture: Built from the ground up with <code>asyncio</code> to handle high-concurrency workloads efficiently.</li> <li>Composable Lifecycle Management: A powerful, registry-based system for managing startup and shutdown events.</li> <li>Automatic Service Discovery: A \"drop-in\" architecture where services are automatically discovered and integrated, no manual configuration required.</li> <li>Structured, Production-Ready Logging: Out-of-the-box structured logging with <code>structlog</code>, providing human-readable logs for development and JSON logs for production.</li> <li>Modern Documentation: A beautiful, maintainable documentation site powered by MkDocs and the Material for MkDocs theme.</li> </ul>"},{"location":"index.html#philosophy","title":"Philosophy","text":"<p>Aegis Stack is built on three pillars:</p> <ol> <li>Speed: Get from idea to production as quickly as possible.</li> <li>Simplicity: Favor clear, Pythonic patterns over complex, magical frameworks.</li> <li>Scalability: Start with a simple monolith and evolve into a distributed system as your needs grow.</li> </ol> <p>To learn more, check out the full Documentation.</p>"},{"location":"index.html#usage","title":"Usage","text":"<p>This project uses a <code>Makefile</code> to provide convenient commands for common tasks.</p>"},{"location":"index.html#running-the-application","title":"Running the Application","text":"<p>To run the local development server with live reloading:</p> <pre><code>make run-local\n</code></pre> <p>The application will be available at <code>http://127.0.0.1:8000</code>.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>To serve the documentation locally with live reloading:</p> <pre><code>make docs-serve\n</code></pre> <p>The documentation will be available at <code>http://127.0.0.1:8001</code>.</p>"},{"location":"index.html#code-quality-and-tests","title":"Code Quality and Tests","text":"<p>To run all checks (linting, type checking, and tests) at once:</p> <pre><code>make check\n</code></pre>"},{"location":"philosophy.html","title":"Aegis Stack Philosophy","text":"<p>The core philosophy of Aegis Stack is built on three pillars: Speed, Simplicity, and Scalability.</p>"},{"location":"philosophy.html#speed-for-builders-who-refuse-to-wait","title":"Speed: For Builders Who Refuse to Wait","text":"<p>Development should be fast. Aegis Stack is designed to get you from idea to production as quickly as possible.</p> <ul> <li>Async-First: Built from the ground up with <code>asyncio</code> to handle high-concurrency workloads efficiently.</li> <li>Full-Stack Python: Use a single language for your entire stack, from the Flet frontend to the FastAPI backend, reducing context-switching and cognitive load.</li> <li>Minimalist by Default: No unnecessary bloat. The stack provides a clean, strong foundation that you can build upon, not a heavy framework you have to fight against.</li> </ul>"},{"location":"philosophy.html#simplicity-powerful-patterns-not-prescriptive-frameworks","title":"Simplicity: Powerful Patterns, Not Prescriptive Frameworks","text":"<p>Aegis Stack favors clear, Pythonic patterns over complex, magical frameworks.</p> <ul> <li>Composable Architecture: Features like the lifecycle registry and service discovery are designed to be extended with plain Python, not complex plugin systems.</li> <li>Clear Separation of Concerns: The project structure is organized logically to separate the frontend, backend, core business logic (services), and framework plumbing.</li> <li>Single Source of Truth: Patterns like <code>mkdocstrings</code> are encouraged to keep documentation tied directly to the code, reducing drift and maintenance overhead.</li> </ul>"},{"location":"philosophy.html#scalability-from-monolith-to-microservices","title":"Scalability: From Monolith to Microservices","text":"<p>Aegis Stack is designed to grow with your application.</p> <ul> <li>Monorepo Foundation: Start with a simple, unified codebase that is easy to manage and develop.</li> <li>Path to Distribution: The architecture is structured to allow for a natural evolution into a distributed system. The same core <code>app</code> library can be used by different entrypoints to run the web server, background workers, and schedulers as independent, scalable services.</li> </ul>"},{"location":"guides/lifecycle.html","title":"Application Lifecycle","text":"<p>Aegis Stack provides a robust, composable system for managing application startup and shutdown events. This allows services to initialize and release resources cleanly, ensuring a stable and predictable application environment.</p> <p>The lifecycle is managed by a single entrypoint: the <code>lifespan</code> context manager in <code>app/integrations/main.py</code>.</p>"},{"location":"guides/lifecycle.html#the-lifecycle-registry","title":"The Lifecycle Registry","text":"<p>Instead of hardcoding logic into the <code>lifespan</code> manager, Aegis Stack uses a dynamic registry pattern. This allows any service to \"hook into\" the application lifecycle without modifying the core integration code.</p> <p>The registry consists of two lists located in <code>app/core/lifecycle.py</code>:</p> <ul> <li><code>STARTUP_TASKS</code></li> <li><code>SHUTDOWN_TASKS</code></li> </ul>"},{"location":"guides/lifecycle.html#registering-a-new-task","title":"Registering a New Task","text":"<p>To add a startup or shutdown task, a service simply needs to define a function and append it to the appropriate list.</p> <p>For example, a hypothetical database service might do this:</p> <pre><code># app/services/database_service.py\nfrom app.core.lifecycle import STARTUP_TASKS, SHUTDOWN_TASKS\n\nasync def connect_to_db():\n    print(\"Connecting to database...\")\n    # ... connection logic ...\n\nasync def close_db_connection():\n    print(\"Closing database connection...\")\n    # ... disconnection logic ...\n\n# Register the functions\nSTARTUP_TASKS.append(connect_to_db)\nSHUTDOWN_TASKS.append(close_db_connection)\n</code></pre>"},{"location":"guides/lifecycle.html#how-it-works","title":"How it Works","text":"<ol> <li>The application uses a Service Discovery mechanism to automatically import all modules within the <code>app/services</code> directory at startup.</li> <li>When a service module is imported, the code at its top level is executed. This is when the <code>STARTUP_TASKS.append(...)</code> calls happen.</li> <li>The <code>lifespan</code> manager then iterates through these populated lists, running all registered startup tasks.</li> <li>Upon shutdown, it iterates through the <code>SHUTDOWN_TASKS</code> in reverse order to ensure a clean teardown.</li> </ol> <p>This pattern makes the system highly extensible. To add a new service with lifecycle hooks, you just drop a file into the <code>services</code> directory.</p>"},{"location":"guides/services.html","title":"Services and Discovery","text":"<p>The <code>app/services</code> directory is the heart of your application's business logic. It's where you answer the question, \"What does my application do?\"</p>"},{"location":"guides/services.html#the-service-layer-pattern","title":"The Service Layer Pattern","text":"<p>A \"service\" is a focused Python module that manages a specific piece of business logic or a connection to an external resource. This pattern separates the core logic of your application from the web-serving and UI-rendering logic, making the entire system easier to test, maintain, and reason about.</p> <p>Good candidates for a service include:</p> <ul> <li>Database Interactions: A <code>database_service.py</code> that contains all your data access logic (CRUD operations).</li> <li>External API Clients: A <code>stripe_service.py</code> that handles all communication with the Stripe API.</li> <li>Complex Business Logic: A <code>reporting_service.py</code> that performs complex data transformations.</li> <li>File Processing: A <code>file_processing_service.py</code> for handling uploads.</li> </ul> <p>The API layer in <code>app/backend/api/</code> should remain \"thin.\" Its job is to handle HTTP requests and validation, then call the appropriate service to do the actual work.</p>"},{"location":"guides/services.html#automatic-service-discovery","title":"Automatic Service Discovery","text":"<p>Aegis Stack uses a dynamic discovery mechanism to make services \"pluggable.\" You do not need to manually import your services into the main application for them to be active.</p>"},{"location":"guides/services.html#how-it-works","title":"How it Works","text":"<ol> <li>At startup, the application scans the <code>app/services</code> directory.</li> <li>It automatically imports any Python module it finds within that directory.</li> <li>This import triggers the top-level code in the service file, which is where services can register themselves with other parts of the application, such as the Lifecycle Registry.</li> </ol>"},{"location":"guides/services.html#the-developer-experience","title":"The Developer Experience","text":"<p>This system creates a powerful and simple developer workflow:</p> <ol> <li>Create a new file in <code>app/services</code>.</li> <li>Write your service logic and any necessary lifecycle hooks.</li> <li>Run the application.</li> </ol> <p>The service is automatically discovered and integrated into the application. There is no need to modify any central configuration or integration files.</p>"}]}