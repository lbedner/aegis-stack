{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Aegis Stack \ud83d\udee1\ufe0f","text":"<p>A production-ready, async-first Python foundation for builders who refuse to wait.</p> <p>Aegis Stack provides a minimal, yet powerful, set of tools and patterns to help you build and deploy robust, scalable applications quickly. It's designed for developers who think in systems, not scripts, and who value speed, simplicity, and scalability.</p>"},{"location":"index.html#core-features","title":"Core Features","text":"<ul> <li>Full-Stack Python: A unified development experience with FastAPI for the backend and Flet for the frontend.</li> <li>Async-First Architecture: Built from the ground up with <code>asyncio</code> to handle high-concurrency workloads efficiently.</li> <li>Composable Lifecycle Management: A powerful, registry-based system for managing startup and shutdown events.</li> <li>Automatic Service Discovery: A \"drop-in\" architecture where services are automatically discovered and integrated, no manual configuration required.</li> <li>Structured, Production-Ready Logging: Out-of-the-box structured logging with <code>structlog</code>, providing human-readable logs for development and JSON logs for production.</li> <li>Modern Documentation: A beautiful, maintainable documentation site powered by MkDocs and the Material for MkDocs theme.</li> </ul>"},{"location":"index.html#philosophy","title":"Philosophy","text":"<p>Aegis Stack is built on three pillars:</p> <ol> <li>Speed: Get from idea to production as quickly as possible.</li> <li>Simplicity: Favor clear, Pythonic patterns over complex, magical frameworks.</li> <li>Scalability: Start with a simple monolith and evolve into a distributed system as your needs grow.</li> </ol>"},{"location":"index.html#getting-started","title":"Getting Started","text":""},{"location":"index.html#environment-setup","title":"Environment Setup","text":"<ol> <li> <p>Copy the environment template: <code>bash    cp .env.example .env</code></p> </li> <li> <p>Customize your environment:    Edit <code>.env</code> to match your local setup. The defaults work for development.</p> </li> </ol>"},{"location":"index.html#usage","title":"Usage","text":"<p>This project uses a <code>Makefile</code> to provide convenient commands for common tasks.</p>"},{"location":"index.html#running-the-application","title":"Running the Application","text":"<p>To run the local development server with live reloading:</p> <pre><code>make run-local\n</code></pre> <p>The application will be available at <code>http://127.0.0.1:8000</code>.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>To serve the documentation locally with live reloading:</p> <pre><code>make docs-serve\n</code></pre> <p>The documentation will be available at <code>http://localhost:8001/aegis-stack/</code>.</p>"},{"location":"index.html#code-quality-and-tests","title":"Code Quality and Tests","text":"<p>To run all checks (linting, type checking, and tests) at once:</p> <pre><code>make check\n</code></pre>"},{"location":"philosophy.html","title":"Aegis Stack Philosophy","text":"<p>The core philosophy of Aegis Stack is built on three pillars: Speed, Simplicity, and Scalability.</p>"},{"location":"philosophy.html#speed-for-builders-who-refuse-to-wait","title":"Speed: For Builders Who Refuse to Wait","text":"<p>Development should be fast. Aegis Stack is designed to get you from idea to production as quickly as possible.</p> <ul> <li>Async-First: Built from the ground up with <code>asyncio</code> to handle high-concurrency workloads efficiently.</li> <li>Full-Stack Python: Use a single language for your entire stack, reducing context-switching and cognitive load.</li> <li>Minimalist by Default: No unnecessary bloat. The stack provides a clean, strong foundation that you can build upon, not a heavy framework you have to fight against.</li> </ul>"},{"location":"philosophy.html#simplicity-powerful-patterns-not-prescriptive-frameworks","title":"Simplicity: Powerful Patterns, Not Prescriptive Frameworks","text":"<p>Aegis Stack favors clear, Pythonic patterns over complex, magical frameworks.</p> <ul> <li>Composable Architecture: Features like the lifecycle registry and service discovery are designed to be extended with plain Python, not complex plugin systems.</li> <li>Clear Separation of Concerns: The project structure is organized logically to separate the frontend, backend, core business logic (services), and framework plumbing.</li> <li>Single Source of Truth: Patterns like <code>mkdocstrings</code> are encouraged to keep documentation tied directly to the code, reducing drift and maintenance overhead.</li> </ul>"},{"location":"philosophy.html#scalability-from-monolith-to-microservices","title":"Scalability: From Monolith to Microservices","text":"<p>Aegis Stack is designed to grow with your application.</p> <ul> <li>Monorepo Foundation: Start with a simple, unified codebase that is easy to manage and develop.</li> <li>Path to Distribution: The architecture is structured to allow for a natural evolution into a distributed system. The same core <code>app</code> library can be used by different entrypoints to run the web server, background workers, and schedulers as independent, scalable services.</li> </ul>"},{"location":"components/index.html","title":"Components Overview","text":"<p>Aegis Stack follows a Voltron philosophy - each component provides a specific capability (like web serving, frontend UI, scheduling) with carefully chosen Python-native implementations that work seamlessly together.</p>"},{"location":"components/index.html#what-are-components","title":"What Are Components?","text":"<p>Components provide core capabilities your application needs:</p> <ul> <li>Web Server: Handles HTTP requests and API endpoints</li> <li>Frontend: Provides user interface and interactions  </li> <li>Scheduling: Manages background tasks and cron jobs (coming soon)</li> <li>Database: Stores and retrieves application data (coming soon)</li> <li>Caching: Improves performance with data caching (coming soon)</li> </ul>"},{"location":"components/index.html#current-components","title":"Current Components","text":""},{"location":"components/index.html#web-server","title":"Web Server","text":"<p>Implementation: FastAPI Capability: High-performance async web framework for building APIs</p>"},{"location":"components/index.html#frontend","title":"Frontend","text":"<p>Implementation: Flet Capability: Python-based UI framework for desktop and web</p>"},{"location":"components/index.html#component-philosophy","title":"Component Philosophy","text":""},{"location":"components/index.html#why-this-approach","title":"Why This Approach?","text":"<ol> <li>Python-First: All components are Python-native for consistency</li> <li>Async Architecture: Every component supports async/await patterns</li> <li>Standards: Each component follows consistent integration patterns</li> <li>Evolution: Start with solid foundations, add capabilities as needed</li> </ol>"},{"location":"components/index.html#how-components-work","title":"How Components Work","text":"<p>Each component:</p> <ul> <li>Integrates cleanly with the lifecycle management system</li> <li>Follows standard patterns for configuration and setup</li> <li>Supports async operation for high performance</li> <li>Provides examples for common use cases</li> </ul> <p>Each component is carefully chosen to maintain Aegis Stack's Python-first, async-native philosophy while providing the capabilities needed for modern applications.</p>"},{"location":"components/frontend.html","title":"Frontend Component","text":"<p>The Frontend component provides the user interface and handles user interactions for your Aegis Stack application.</p>"},{"location":"components/frontend.html#current-implementation-flet","title":"Current Implementation: Flet","text":"<p>Flet is the current frontend implementation, chosen for its Python-native approach and ability to create both web and desktop applications from the same codebase.</p>"},{"location":"components/frontend.html#why-flet","title":"Why Flet?","text":"<ul> <li>Pure Python: Write UI logic in Python without JavaScript/HTML/CSS</li> <li>Multi-Platform: Same code runs as web app, desktop app, or mobile app</li> <li>Fast Development: No context switching between languages</li> <li>Modern UI: Based on Flutter, providing smooth animations and responsive design</li> <li>Real-time: Built-in WebSocket support for live updates</li> </ul>"},{"location":"components/frontend.html#how-its-integrated","title":"How It's Integrated","text":"<p>Flet is set up in the <code>app/frontend/</code> directory and integrated with FastAPI:</p> <pre><code># app/frontend/main.py\nimport flet as ft\n\ndef create_frontend_app():\n    \"\"\"Create and return Flet session handler\"\"\"\n\n    async def main(page: ft.Page):\n        page.title = \"Aegis Stack\"\n        page.theme_mode = ft.ThemeMode.LIGHT\n\n        # Your UI components here\n        page.add(\n            ft.Text(\"Welcome to Aegis Stack!\", size=24),\n            ft.ElevatedButton(\"Click me!\", on_click=handle_click)\n        )\n\n    return main\n\nasync def handle_click(e):\n    e.page.add(ft.Text(\"Button clicked!\"))\n    e.page.update()\n</code></pre>"},{"location":"components/frontend.html#integration-with-fastapi","title":"Integration with FastAPI","text":"<p>Flet mounts seamlessly on FastAPI using the official integration:</p> <pre><code># app/integrations/main.py\nimport flet.fastapi as flet_fastapi\n\n# Create and mount the Flet app\nsession_handler = create_frontend_app()\nflet_app = flet_fastapi.app(session_handler)\napp.mount(\"/\", flet_app)\n</code></pre>"},{"location":"components/frontend.html#key-features","title":"Key Features","text":""},{"location":"components/frontend.html#component-based-architecture","title":"Component-Based Architecture","text":"<pre><code># Reusable components\nclass CustomButton(ft.UserControl):\n    def __init__(self, text, on_click):\n        super().__init__()\n        self.text = text\n        self.on_click = on_click\n\n    def build(self):\n        return ft.ElevatedButton(\n            text=self.text,\n            on_click=self.on_click\n        )\n</code></pre>"},{"location":"components/frontend.html#state-management","title":"State Management","text":"<pre><code># Reactive state updates\nasync def update_counter(e):\n    counter.value += 1\n    counter.update()  # Automatically syncs with browser\n</code></pre>"},{"location":"components/frontend.html#responsive-design","title":"Responsive Design","text":"<pre><code># Adaptive layouts\nft.ResponsiveRow([\n    ft.Container(\n        content=ft.Text(\"Left panel\"),\n        col={\"sm\": 6, \"md\": 4, \"xl\": 3}\n    ),\n    ft.Container(\n        content=ft.Text(\"Right panel\"), \n        col={\"sm\": 6, \"md\": 8, \"xl\": 9}\n    )\n])\n</code></pre>"},{"location":"components/frontend.html#development-experience","title":"Development Experience","text":"<ul> <li>Hot Reload: Changes appear instantly during development</li> <li>Python Debugging: Use standard Python debuggers and tools</li> <li>Type Safety: Full type hints and IDE support</li> <li>No Build Step: No compilation or bundling required</li> </ul>"},{"location":"components/frontend.html#integration-with-aegis-stack","title":"Integration with Aegis Stack","text":"<p>Flet integrates seamlessly with Aegis Stack's architecture:</p> <ul> <li>Lifecycle Management: Automatic startup and shutdown handling</li> <li>Structured Logging: Integrated with Aegis Stack's logging system</li> <li>Async Compatibility: Works with FastAPI's async request handling</li> </ul>"},{"location":"components/frontend.html#performance-characteristics","title":"Performance Characteristics","text":"<p>Flet provides:</p> <ul> <li>Real-time Updates: WebSocket-based communication with server</li> <li>Efficient Rendering: Flutter's optimized rendering engine</li> <li>Small Bundle Size: No heavy JavaScript frameworks</li> <li>Cross-Platform: Same performance characteristics across platforms</li> </ul>"},{"location":"components/frontend.html#deployment-options","title":"Deployment Options","text":"<p>Flet applications can be deployed as:</p> <ul> <li>Web App: Served through FastAPI (current setup)</li> <li>Desktop App: Standalone executable for Windows/Mac/Linux</li> <li>Mobile App: Native iOS/Android applications</li> <li>PWA: Progressive Web App with offline capabilities</li> </ul> <p>This makes Flet an ideal choice for Aegis Stack's Python-first, async-native philosophy.</p>"},{"location":"components/webserver.html","title":"Web Server Component","text":"<p>The Web Server component handles HTTP requests, API endpoints, and web traffic for your Aegis Stack application.</p>"},{"location":"components/webserver.html#current-implementation-fastapi","title":"Current Implementation: FastAPI","text":"<p>FastAPI is the current web server implementation, chosen for its high performance, automatic API documentation, and excellent async support.</p>"},{"location":"components/webserver.html#why-fastapi","title":"Why FastAPI?","text":"<ul> <li>High Performance: Built on Starlette and Pydantic, one of the fastest Python frameworks</li> <li>Async Native: Perfect match for Aegis Stack's async-first architecture  </li> <li>Type Safety: Automatic validation and serialization using Python type hints</li> <li>Auto Documentation: Generates OpenAPI/Swagger docs automatically</li> <li>Modern: Designed for Python 3.6+ with modern language features</li> </ul>"},{"location":"components/webserver.html#how-its-integrated","title":"How It's Integrated","text":"<p>FastAPI is set up in the <code>app/backend/</code> directory:</p> <pre><code># app/backend/main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\ndef create_backend_app(app: FastAPI) -&gt; FastAPI:\n    \"\"\"Configure FastAPI app with all backend concerns\"\"\"\n\n    # Basic CORS\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    # Include all routes\n    include_routers(app)\n\n    return app\n</code></pre>"},{"location":"components/webserver.html#adding-api-routes","title":"Adding API Routes","text":"<p>Routes are organized in <code>app/backend/api/</code>:</p> <pre><code># app/backend/api/health.py\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"service\": \"aegis-stack\"}\n</code></pre> <p>Register routes in <code>app/backend/api/routing.py</code>:</p> <pre><code>from app.backend.api import health\n\ndef include_routers(app: FastAPI) -&gt; None:\n    app.include_router(health.router, tags=[\"health\"])\n</code></pre>"},{"location":"components/webserver.html#configuration","title":"Configuration","text":"<p>FastAPI is configured through the integration layer and runs with:</p> <ul> <li>CORS enabled for cross-origin requests</li> <li>Automatic JSON serialization </li> <li>Built-in validation using Pydantic models</li> <li>Exception handling for clean error responses</li> </ul>"},{"location":"components/webserver.html#development-features","title":"Development Features","text":"<ul> <li>Auto-reload during development</li> <li>Interactive docs at <code>/docs</code> (Swagger UI)</li> <li>Alternative docs at <code>/redoc</code> </li> <li>OpenAPI schema at <code>/openapi.json</code></li> </ul>"},{"location":"components/webserver.html#integration-with-aegis-stack","title":"Integration with Aegis Stack","text":"<p>FastAPI aligns perfectly with Aegis Stack's core principles:</p> <ul> <li>Python-First: Pure Python with excellent type safety</li> <li>Async-Native: Built for async/await from the ground up</li> <li>Developer Experience: Automatic validation, serialization, and documentation</li> <li>Production Ready: High performance with excellent error handling</li> </ul>"},{"location":"components/webserver.html#performance-characteristics","title":"Performance Characteristics","text":"<p>FastAPI provides:</p> <ul> <li>Async request handling for high concurrency</li> <li>Automatic validation without performance penalty</li> <li>JSON serialization optimized with orjson under the hood</li> <li>Middleware support for cross-cutting concerns</li> </ul> <p>FastAPI's async-first design allows Aegis Stack to handle thousands of concurrent connections efficiently while maintaining type safety and developer productivity.</p>"},{"location":"guides/lifecycle.html","title":"Application Lifecycle","text":"<p>Aegis Stack provides a robust, composable system for managing application startup and shutdown events. This allows services to initialize and release resources cleanly, ensuring a stable and predictable application environment.</p> <p>The lifecycle is managed by a single entrypoint: the <code>lifespan</code> context manager in <code>app/integrations/main.py</code>.</p>"},{"location":"guides/lifecycle.html#the-lifecycle-registry","title":"The Lifecycle Registry","text":"<p>Instead of hardcoding logic into the <code>lifespan</code> manager, Aegis Stack uses a dynamic registry pattern. This allows any service to \"hook into\" the application lifecycle without modifying the core integration code.</p> <p>The registry consists of two lists located in <code>app/core/lifecycle.py</code>:</p> <ul> <li><code>STARTUP_TASKS</code></li> <li><code>SHUTDOWN_TASKS</code></li> </ul>"},{"location":"guides/lifecycle.html#registering-a-new-task","title":"Registering a New Task","text":"<p>To add a startup or shutdown task, a service simply needs to define a function and append it to the appropriate list.</p> <p>For example, a hypothetical database service might do this:</p> <pre><code># app/services/database_service.py\nfrom app.core.lifecycle import STARTUP_TASKS, SHUTDOWN_TASKS\n\nasync def connect_to_db():\n    print(\"Connecting to database...\")\n    # ... connection logic ...\n\nasync def close_db_connection():\n    print(\"Closing database connection...\")\n    # ... disconnection logic ...\n\n# Register the functions\nSTARTUP_TASKS.append(connect_to_db)\nSHUTDOWN_TASKS.append(close_db_connection)\n</code></pre>"},{"location":"guides/lifecycle.html#how-it-works","title":"How it Works","text":"<ol> <li>The application uses a Service Discovery mechanism to automatically import all modules within the <code>app/services</code> directory at startup.</li> <li>When a service module is imported, the code at its top level is executed. This is when the <code>STARTUP_TASKS.append(...)</code> calls happen.</li> <li>The <code>lifespan</code> manager then iterates through these populated lists, running all registered startup tasks.</li> <li>Upon shutdown, it iterates through the <code>SHUTDOWN_TASKS</code> in reverse order to ensure a clean teardown.</li> </ol> <p>This pattern makes the system highly extensible. To add a new service with lifecycle hooks, you just drop a file into the <code>services</code> directory.</p>"},{"location":"guides/services.html","title":"Services and Discovery","text":"<p>The <code>app/services</code> directory is the heart of your application's business logic. It's where you answer the question, \"What does my application do?\"</p>"},{"location":"guides/services.html#the-service-layer-pattern","title":"The Service Layer Pattern","text":"<p>A \"service\" is a focused Python module that manages a specific piece of business logic or a connection to an external resource. This pattern separates the core logic of your application from the web-serving and UI-rendering logic, making the entire system easier to test, maintain, and reason about.</p> <p>Good candidates for a service include:</p> <ul> <li>Database Interactions: A <code>database_service.py</code> that contains all your data access logic (CRUD operations).</li> <li>External API Clients: A <code>stripe_service.py</code> that handles all communication with the Stripe API.</li> <li>Complex Business Logic: A <code>reporting_service.py</code> that performs complex data transformations.</li> <li>File Processing: A <code>file_processing_service.py</code> for handling uploads.</li> </ul> <p>The API layer in <code>app/backend/api/</code> should remain \"thin.\" Its job is to handle HTTP requests and validation, then call the appropriate service to do the actual work.</p>"},{"location":"guides/services.html#automatic-service-discovery","title":"Automatic Service Discovery","text":"<p>Aegis Stack uses a dynamic discovery mechanism to make services \"pluggable.\" You do not need to manually import your services into the main application for them to be active.</p>"},{"location":"guides/services.html#how-it-works","title":"How it Works","text":"<ol> <li>At startup, the application scans the <code>app/services</code> directory.</li> <li>It automatically imports any Python module it finds within that directory.</li> <li>This import triggers the top-level code in the service file, which is where services can register themselves with other parts of the application, such as the Lifecycle Registry.</li> </ol>"},{"location":"guides/services.html#the-developer-experience","title":"The Developer Experience","text":"<p>This system creates a powerful and simple developer workflow:</p> <ol> <li>Create a new file in <code>app/services</code>.</li> <li>Write your service logic and any necessary lifecycle hooks.</li> <li>Run the application.</li> </ol> <p>The service is automatically discovered and integrated into the application. There is no need to modify any central configuration or integration files.</p>"}]}